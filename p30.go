package main

import (
	"sort"
	"strings"
)

func divisorSum(max int) []int {
	divSum := make([]int, max)
	for d := 1; d < max; d++ {
		for m := 2*d; m < max; m += d {
			divSum[m] += d
		}
	}
	
	return divSum
}

func problem21() string {
	const max = 10000
	divSum := divisorSum(max)
	amiSum := 0
	for i := 1; i < max; i++ {
		di := divSum[i]
		if di != i && di < max && divSum[di] == i {
			amiSum += i
		}
	}
	
	return itoa(amiSum)
}

func problem22() string {
	line := ReadAllLines("data/p22.txt")[0] // all content is in one line
	names := strings.Split(line, ",")
	sort.Strings(names)

	nameScore := func(name string) int64 {
		sum := int64(0)
		for _, c := range name {
			sum += int64(int(c) - int('A') + 1)
		}
		return sum
	}

	score := int64(0)
	for i, name := range names {
		name = strings.Replace(name, "\"", "", 2)
		score += nameScore(name) * int64(i+1)				
	}

	return i64toa(score)
}

func problem23() string {
	// find all abundant numbers
	const max = 30000 
	divSum := divisorSum(max)

	aCount := 0
	abundants := make([]int, max)
	for i := 1; i < max; i++ {
		if divSum[i] > i {
			abundants[aCount] = i
			aCount++
		}
	}

	isSumOfTwoA := NewBitSet(max)
	for i := 0; i < aCount; i++ {
		ai := abundants[i]
		for j := i; j < aCount ; j++ {
			sum := ai + abundants[j]
			if sum < max { 
				isSumOfTwoA.Set(sum) 
			} else { 
				break 
			}
		}
	}

	sum := 0
	for i := 1; i < max; i++ {
		if !isSumOfTwoA.Get(i) {
			sum += i
		}
	}

	return itoa(sum)
}

func problem24() string {
	p := NewPermutation(10)
	for i := 1; i < 1000000; i++ {
		p.NextPermutation()
	}
	return p.ToString()
}

func problem25() string {
	i, max := 1, bigExp(10, 999)
	for tmp, cur, next := NewBig(1), NewBig(1), NewBig(1); cur.Cmp(max) == -1 ; i++ {
		tmp.Set(next)
		next.Add(cur, next)
		cur.Set(tmp)
	}

	return itoa(i)
}

func Divide(numer, denom int) (quot, rem int) {
	quot = numer / denom
	rem = numer - (denom * quot)
	return
}

func RecurrenceLength(numer, denom int) int {
	visRem := NewBitSet(denom + 2)
	_, rem := Divide(numer, denom)

	for i := 0; rem > 0; i++ {
		if visRem.Get(rem) { return i } // reached the same remainder twice, so recurrence length is known.
		visRem.Set(rem)

		_, rem = Divide(rem * 10, denom)
	}

	// reached here: so rem == 0 ; so not a recurring fraction
	return 0
}

func problem26() string {
	maxD, maxLen := 0, 0
	for d := 1; d < 1000; d++ {
		dLen := RecurrenceLength(1, d)
		if maxLen < dLen {
			maxD, maxLen = d, dLen
		}
	}
	return itoa(maxD)
}

func problem27() string {
	// max { a^2 + an + b } where |a|, |b| < 1000 is < { 1000^2 + 1000n + 1000 }.
	// when n = 1000, the above expression is divisible by 1000, so n < 1000
	// so max { ... } is 2 * 1000^2 + 1000 = 2001000
	const max = 2001002
	composites := BuildPrimeSieve(max)

	maxA, maxB, maxLen := 0, 0, 0
	for b := 2; b < 1000; b++ { // negative b will not be prime (see next line)
		if composites.Get(b) { continue } // the first term (when n=0) is 0^2 + 0*a + b = b.
		for a := -999; a < 1000; a++ {
			n := 1
			for (n*n + a*n + b > 0) && !composites.Get(n*n + a*n + b) { 
				n++ 
			}

			if n > maxLen { 
				maxA, maxB, maxLen = a, b, n 
			}
		}
	}

	return itoa(maxA*maxB)
}

func problem28() string {
	sq := 1001
	n := (sq / 2) + 1
	
	// the sum of each ring is 4 * the west axis: { 1, 6, 19, 40, ... }
	// this sequence is generated by quadratic 4x^2 - 7x + 4
	// sum_i_n (n^2) = n(n+1)(2n+1)/6
	// sum_i_n (n)   = n(n+1)/2
	// sum_i_n (1) 	 = n
	sqSum := func(i int) int { return i*(i+1)*(2*i+1) / 6 }
	linSum := func(i int) int { return i*(i+1)/2 }
	s := 4*(4*sqSum(n) - 7*linSum(n) + 4*n) - 3 // -3 since 1 is counted 4 times (but only occurs once)
	return itoa(s)
}

func problem30() string {
	fifthPow := make([]int, 10)
	for i := 0; i < 10; i++ {
		isq := i*i
		fifthPow[i] = isq * isq * i
	}

	sumOfAll := 0
	for i := 2; i < 700000; i++ {
		sumOfD := 0
		for _, d := range toDigits(i) {
			sumOfD += fifthPow[d]
		}
		if sumOfD == i { println(i); sumOfAll += i }
	}
	return itoa(sumOfAll)
}
