package main

func divisorSum(max int) []int {
	divSum := make([]int, max)
	for d := 1; d < max; d++ {
		for m := 2*d; m < max; m += d {
			divSum[m] += d
		}
	}

	return divSum
}

func problem21() string {
	const max = 10000
	divSum := divisorSum(max)
	amiSum := 0
	for i := 1; i < max; i++ {
		di := divSum[i]
		if di != i && di < max && divSum[di] == i {
			amiSum += i
		}
	}
	
	return itoa(amiSum)
}

func problem23() string {
	// find all abundant numbers
	const max = 30000 
	divSum := divisorSum(max)

	aCount := 0
	abundants := make([]int, max)
	for i := 1; i < max; i++ {
		if divSum[i] > i {
			abundants[aCount] = i
			aCount++
		}
	}

	isSumOfTwoA := NewBitSet(max)
	for i := 0; i < aCount; i++ {
		ai := abundants[i]
		for j := i; j < aCount ; j++ {
			sum := ai + abundants[j]
			if sum < max { 
				isSumOfTwoA.Set(sum) 
			} else { 
				break 
			}
		}
	}

	sum := 0
	for i := 1; i < max; i++ {
		if !isSumOfTwoA.Get(i) {
			sum += i
		}
	}

	return itoa(sum)
}

func problem25() string {
	i, max := 1, bigExp(10, 999)
	for tmp, cur, next := NewBig(1), NewBig(1), NewBig(1); cur.Cmp(max) == -1 ; i++ {
		tmp.Set(next)
		next.Add(cur, next)
		cur.Set(tmp)
	}

	return itoa(i)
}

func problem28() string {
	sq := 1001
	n := (sq / 2) + 1
	
	// the sum of each ring is 4 * the west axis: { 1, 6, 19, 40, ... }
	// this sequence is generated by quadratic 4x^2 - 7x + 4
	// sum_i_n (n^2) = n(n+1)(2n+1)/6
	// sum_i_n (n)   = n(n+1)/2
	// sum_i_n (1) 	 = n
	sqSum := func(i int) int { return i*(i+1)*(2*i+1) / 6 }
	linSum := func(i int) int { return i*(i+1)/2 }
	s := 4*(4*sqSum(n) - 7*linSum(n) + 4*n) - 3 // -3 since 1 is counted 4 times (but only occurs once)
	return itoa(s)
}
